# 헤더

TCP, IP, Ethernet 다들 한 번 쯤 들어 봤을 것이다.  
자세히 설명(?)해주겠다.

### TCP
Transmission Control Protocol 뜻 그대로 전송제어 프로토콜이다. 근거리 통신망에서 인터넷에 연결된 컴퓨터 가넹 일련의 옥텟을 안정적으로 순서대로 에러없이 교환할 수 있도록 한다.
기본적으로 IP 와 함께 사용 되며 IP는 데이타 교환을 하고 TCP는 데이터 누락 검사, 패킷 순서 검사, 데이터 교정 관련된 기능을 수행한다.

>TCP 헤더 

중요하다. 그리고 우리가 패킷을 분석할때 사용할 것이다.

<img src="http://lh6.ggpht.com/_Os5qf5urx_A/S1B2rISxU_I/AAAAAAAABBY/59uGrupJwjU/s800/tcp_header.png">

위 그림은 TCP header 이미지이다.  
하나씩 기능을 설명해 주겠다.
* Souerce port  
송신측 포트 번호. 통신 시 사용하는 포트번호이다.

* Destination port  
수신측 포트 번호. 메세지를 받는 쪽의 포트번호이다.

* Sequence number  
패킷을 보내는 도중에 뒤바뀔수 도 있는데 그것을 막기 위해 수신측에서 재조립할 경우 이것을 이용해 재 조립 한다. 한마디로 순번

* Acknowledgement number  
다음에 수신할 것을 기다리는 Sequence number, 보내는 것이 잘 도착했다고 알려주는 숫자이다.

* Data offset  
TCP 헤더의 크기, 최솟값은 20, 최댓값은 60이다. head length 라고도 불린다.

* Reserved  
나도 아직까지 이것이 정확히 무슨 일을 하는지 잘 모른다 아시는 분 커밋 ㄱ

* flag (8bits)  
여러 친구들이 모여 있다. 그 자리에 1이 있다면 그 의미를 가진다.  
    * CWR (Congestion Window Reduced)  
    수신자의 버퍼의 상태를 송신자에게 알려 송신 window size 를 줄이기 위해 사용

    * ECE (ENC-echo)  
    네크워크의 혼잡 가능성을 미리 탐지, 이를 송신측에 미리 알려주어 전송속도를 조절한다.

    * URG (Urgent Flag)  
    긴급한 데이터를 처리할 때 사용. 이 부분이 1로 되어 있으면 이 패킷을 먼저 처리

    * ACK (Acknowledgement Flag)  
    접속에 응답을 할 때 사용한다. 

    * PSH (Push Flag)  
    데이터를 빨리 보내고자 할 때 사용. 데이터를 가능한 빨리 상위  계층으로 올려보냄 OSI 7 Layor 는 다들 알고 있져...?

    * RST (Reset Flag)  
    원인을 알 수 없는 장애로 통신을 복구할 수 없는 경우 또는 일방적으로 세션을 끊기 위해 사용. 그래서 Reset임.

    * SYN (Synchronize Flag)  
    접속을 요청할 때 사용됨. Ack 짝꿍.

    * FIN (Fin Flag)  
    데이터 전송을 완료한 후 또는 세션 종료 요청을 할 경우 사용

* Window Size  
송신 시스템의 가용 수신 버퍼의 크기를 바이트 단위로 나타냄.

* Checksum  
데이터가 전송중에 손실되지 않고 원본과 동일한지 검사함.

* Urgent pointer  
전송한 데이터의 맨 마지막 바이트를 가리킴. 신경 ㄴㄴ

* Option  
옵션 데이터, tcp에 옵션을 주는 거임 나도 잘 모름. 

### IP  
Internet Protocol 쉽게 말해 데이터 패킷을 전송하기 위해 각각 부여된 주소같은 의미이다. IP는 자신이 목적지만 설정해주고 패킷이 도착하든 말든 상관안한다. 그래서 TCP와 함께 쓰인다.

> IP Header  

<img src="http://cfile9.uf.tistory.com/image/271E85365551641124D418">

위 그림은 ip header 이다. 하나씩 친절히 설명하겠다.

* Version  
현재는 ipv4를 사용한다. 그런 버전을 나타내는 곳이다.

* Header Length  
IP 헤더의 길이를 나타낸다. 최소 20byte 부터 최대 60byte(옵션 포함) 를 나타낸다. 

* Type of Service (ToS)  
8비트로 구성된 필드로서 앞 3비트는 우선순위를 결정하는 비트이고, 뒤의 5비트는 서비스 유형을 나타내는 비트

* Total Length  
헤더+데이터의 크기 

* Identification  
ip 패킷은 생성될 당시에 식별 번호를 부여 받는데 IP 패킷이 분리되어 목적지에 도착할 경우 각각의 잘게 쪼개진 패킷은 식별 번호가 같기 때문에 전송된 패킷이 다른 전송된 패키ㅣㅅ과 같은 식별 번호를 가진다면 같은 패킷에서 조각났음을 알 수있다. 

* Flag  
3비트로 이루어짐
    * reserved flag  
    항상 0으로 설정하는 플래그

    * don't fragment flag  
    비트값이 1이면 패킷을 자르지 못한다는 의미

    * more fragment flag  
    비트값이 1이면 잘려진 패킷이 더 있다는 의미

* Fragment offset  
패킷이 단편화가 일어날 경우 원래 데이터 그램의 몇번째 위치에부터 단편화가 일어났는지 나타냄

* Time To Live  
ip 패킷이 라우터를 지나칠 때마다 라우터는 TTL 값을 1씩 감소 시키고 TTL 이 0이 되면 패킷은 더 이상 전송되지 않는다. 그리고 패킷을 폐기한다.

* Protocol  
4계층에서 어떤 프로토콜을 사용하고 있는지를 명시해두는 부분
    >대표적인 프로토콜 넘버와 타입  
    <table>
    <tr>
        <th>Protocol Number</th>
        <th>Protocol Type</th>
    </tr>
    <tr>
        <td>1</td>
        <td>ICMP</td>
    </tr>
    <tr>
        <td>2</td>
        <td>IGMP</td>
    </tr>
    <tr>
        <td>6</td>
        <td>TCP</td>
    </tr>
    <tr>
        <td>17</td>
        <td>UDP</td>
    </tr>
    </table>

* Header Checksum  
IP 헤더가 생성되거나 수정될 때마다 IP 헤더 내 비트를 검사함. IP 패킷을 전송하게 되면, 계산 결과가 똑같이 나타나면 IP 헤더의 모든 비트는 정확하게 전송된 것이다.

* Source Address  
데이터를 전송한 호스트의 IP 주소

* Destination Address  
데이터를 전송한 호스트의 IP 주소

* Option  
IP 헤더의 옵션이다. 

### Ethernet  
각각의 기기들의 고유의 MAC 주소를 통해 호스트간의 데이터를 주고 받는 방식을 사용.  
우리가 실생활에서 사용하는 LAN에 사용하기 위해 개발된 기술

> Ethernet Header  

* Destination MAC Address  
목적지 MAC 주소

* Source MAC Address  
출발지 MAC 주소

* Ethernet Type  
패킷의 타입을 명시

정리는 여기 까지 해두고 이것을 구조체로 만들어서 관리해야 한다.

### TCP, IP, Ethernet Header Structure  
```c
struct ether_addr
{
    unsigned char ether_addr_octet[6]; 
};
 
struct ether_header
{
    struct  ether_addr ether_dhost; 
    struct  ether_addr ether_shost; 
    unsigned short ether_type;
};

struct ip_addr
{
    unsigned char ip_addr_octet[4]; 
};
 
struct ip_header
{
    unsigned char ip_header_len:4;
    unsigned char ip_version:4;
    unsigned char ip_tos;
    unsigned short ip_total_length;
    unsigned short ip_id;
    unsigned char ip_frag_offset:5;
    unsigned char ip_more_fragment:1;
    unsigned char ip_dont_fragment:1;
    unsigned char ip_reserved_zero:1;
    unsigned char ip_frag_offset1;
    unsigned char ip_ttl;
    unsigned char ip_protocol;
    unsigned short ip_checksum;
    struct ip_addr ip_srcaddr;
    struct ip_addr ip_destaddr;
};
 
struct tcp_header
{
    unsigned short source_port;
    unsigned short dest_port;
    unsigned int sequence;
    unsigned int acknowledge;
    unsigned char reserved_part:4;
    unsigned char data_offset:4;
    unsigned char fin:1;
    unsigned char syn:1;
    unsigned char rst:1;
    unsigned char psh:1;
    unsigned char ack:1;
    unsigned char urg:1;
    unsigned char ecn:1;
    unsigned char cwr:1;
    unsigned short window;
    unsigned short checksum;
    unsigned short urgent_pointer;
};
```